#!/usr/bin/env ruby
# vim: set ts=2 sw=2 noet :

require 'getoptlong'

$ctypes = { "string"  => "const char *",
            "int"     => "int",
            "boolean" => "gboolean" }
$gxrtypes = { "string"  => "GXR_VALUE_STRING",
              "int"     => "GXR_VALUE_INT",
              "boolean" => "GXR_VALUE_BOOLEAN" }


module GXR
	class BadSignature < Exception; end

	class Method
		def initialize(sig, namespace=nil)
			raise BadSignature unless sig =~ /^(\w+) ([\w\.]+)\((.*)\)$/
			@rettype, @methodname, @args = $1, $2, $3.split(/,\s+/)
			if namespace and @methodname =~ /(\w+)\.(.+)/
				@funcname = "#{namespace}_#{$2}"
			else
				@funcname = @methodname.gsub(/\./, '_')
			end
			@args.map! { |argstr| argstr.split(/\s+/) }
		end

		def buildheader
			argstr = @args.map{ |type, name| "#{$ctypes[type]} arg_#{name}" }.join(", ")
			return "#{$ctypes[@rettype]} #{@funcname}(GXRContext *ctx, #{argstr}, GError **err);"
		end

		def buildsource
			argstr = @args.map{ |type, name| "#{$ctypes[type]} arg_#{name}" }.join(", ")

			out = ""
			out << <<-EOT
#{$ctypes[@rettype]}
#{@funcname}(GXRContext *ctx, #{argstr}, GError **err) {
	xmlDocPtr doc; xmlNodePtr np;
	char *retval = NULL;
	#{$ctypes[@rettype]} ret = 0; /* meaningless unless err isn't set. */

	gxr_make_doc(&doc, &np, "#{@methodname}");
		EOT
			@args.each { |type, name|
				out << <<-EOT
	gxr_add_param_#{type.ljust(7)}(np, arg_#{name});
				EOT
			}
			out << <<-EOT

	if (!gxr_run_request(ctx, doc, #{$gxrtypes[@rettype]}, &retval, err))
		goto out;

	#{case @rettype
	when 'int'
		"ret = atoi(retval);"
	when 'string'
	  "ret = g_strdup(retval);"
	end}
	xmlFree(retval);
out:
	xmlFreeDoc(doc);
	return ret;
}
			EOT
			out
		end
	end
	class Struct
		def initialize(decl, namespace)
			raise BadSignature unless decl =~ /^struct (\w+) {(.*)}$/m
			@name, @fields = $1, $2.strip.split(/\s*,\s*/)
			@structname = "#{namespace}_#{@name}"
			$ctypes[@name] = "#{@structname} *"
			@fields.map! { |fstr| fstr.split(/\s+/) }
		end
		def buildheader
			out = "typedef struct {\n"
			@fields.each { |type, name|
				out << "\t#{$ctypes[type].sub(/const /,'')} #{name};\n"
			}
			out << "} #{@structname};\n"
			out << "#{$ctypes[@name]} #{@structname}_new(void);\n"
			out << "void #{@structname}_free(#{$ctypes[@name]});\n"
			out
		end
		def buildsource
			out = ""
			out << <<-EOT
#{$ctypes[@name]}
#{@structname}_new(void) {
	return g_new0(#{@structname}, 1);
}

			EOT
			out << "void\n#{@structname}_free(#{$ctypes[@name]} p) {\n"
			@fields.each { |type, name|
				out << "\tg_free(p->#{name});\n" if type == 'string'
			}
			out << "\tg_free(p);\n"
			out << "}\n"
		end
	end
end

cmdline = $0 + " " + ARGV.join(" ")

opts = GetoptLong.new(
	[ "--namespace", "-n", GetoptLong::REQUIRED_ARGUMENT ]
)
namespace=nil
opts.each { |opt, arg|
	case opt
	when '--namespace'
		namespace = arg
  end
}

outfile = ARGV.shift
usage unless outfile

namespace ||= File.basename(outfile)

sourcefile = File.new(outfile + ".c", "w")
headerfile = File.new(outfile + ".h", "w")
headerdefine = namespace.upcase + "_H"

methods = []
structs = []
infile = ARGV.shift
if infile 
  infile = File.open(infile)
else
  infile = $stdin
end
data = ""
infile.each_line { |l|
	next if l =~ /^\s*#/
	data << l
}
decls = data.split(/\s*;\s*/)
decls.each { |decl|
	if decl =~ /^struct/
		structs << GXR::Struct.new(decl, namespace)
	else
		methods << GXR::Method.new(decl, namespace)
	end
}

headerfile.print <<EOT
/* generated by gxr: '#{cmdline}'. */

#ifndef #{headerdefine}
#define #{headerdefine}

#include <gxr.h>

#{structs.map{|s| s.buildheader}.join("\n")}

#{methods.map{|m| m.buildheader}.join("\n")}

#endif /* #{headerdefine} */
EOT
puts "generated #{outfile}.h"

sourcefile.print <<EOT
/* generated by gxr: '#{cmdline}'. */

#include "gxr-internal.h"
#include "#{outfile}.h"

#{structs.map{|s| s.buildsource}.join("\n")}
#{methods.map{|m| m.buildsource}.join("\n")}
EOT
puts "generated #{outfile}.c"

